<?php
/**
 * @file
 * Create tokens and integrate with pathauto alias generation.
 */

/**
 * Implements hook_enable().
 */
function ding_path_alias_enable() {
  // New module weights in core: put devel as the very last in the chain.
  db_update('system')
    ->fields(array(
      'weight' => 1,
    ))
    ->condition('type', 'module')
    ->condition('name', 'ding_path_alias')
    ->execute();
}

/**
 * Implements hook_token_info().
 */
function ding_path_alias_token_info() {
  $info['types']['og-field'] = array(
    'name' => t('Organic group field'),
    'description' => t('Organic group field holding relation to a group.'),
  );

  $info['tokens']['og-field']['gid'] = array(
    'name' => t('Organic groups group ID'),
    'description' => t('The unique ID of the organic groups group.'),
    'type' => 'integer',
  );

  $info['tokens']['og-field']['node'] = array(
    'name' => t('Organic groups node'),
    'description' => t('The node of the organic group if any.'),
    'type' => 'node',
  );

  return $info;
}

/**
 * Implements hook_token_info_alter().
 */
function ding_path_alias_token_info_alter(&$info) {
  $info['tokens']['node']['ding_event_library']['type'] = 'og-field';
  $info['tokens']['node']['ding_news_library']['type'] = 'og-field';
  return $info;
}

/**
 * Implements hook_tokens().
 */
function ding_path_alias_tokens($type, $tokens, array $data = array(), array $options = array()) {
  $replacements = array();
  if ($type == 'node' && !empty($data['node'])) {
    $node = $data['node'];
    $node_wrapper = entity_metadata_wrapper('node', $node);
    if ($node->type == 'ding_event') {
      $tokens = token_find_with_prefix($tokens, 'ding_event_library');
      $gid = $node->ding_event_library['und'][0]['gid'];
    }
    elseif ($node->type == 'ding_news') {
      $tokens = token_find_with_prefix($tokens, 'ding_news_library');
      $gid = $node->ding_news_library['und'][0]['gid'];
    }

    // Add gid if needed.
    foreach ($tokens as $name => $original) {
      if ($name == 'gid') {
        $replacements[$original] = $gid;
      }
    }

    // Add node tokens.
    if ($node_tokens = token_find_with_prefix($tokens, 'node')) {
      $group = og_load($gid);
      if ($group->entity_type == 'node') {
        $group_node = node_load($group->etid);
        $replacements += token_generate('node', $node_tokens, array('node' => $group_node), $options);
      }
    }
  }
  return $replacements;
}

/**
 * Implements hook_path_alias_types().
 *
 * Used primarily by the bulk delete form.
 */
function ding_path_alias_path_alias_types() {
  $objects = array();
  if (module_exists('ding_library') && module_exists('ding_news')) {
    $objects['library/%/news'] = t('Library news pages');
  }
  if (module_exists('ding_library') && module_exists('ding_event')) {
    $objects['library/%/events'] = t('Library event pages');
  }
  if (module_exists('ding_library')) {
    $objects['node/%/about'] = t('About library page');
  }
  return $objects;
}

/**
 * Implements hook_pathauto().
 */
function ding_path_alias_pathauto($op) {
  switch ($op) {
    case 'settings':
      /**
       * Pathauto module isn't create with the kind of functionality we have in
       * mind: Create a bunch of different path aliases with different url
       * patterns. We need to create a setting for each pattern type we want to
       * use as the batch callback needs to know what the internal url will be.
       * Since pathauto will key the form items on the module value, we need to
       * create a unique module defition per url pattern.
       */
      $settings = array();
      if (module_exists('ding_library') && module_exists('ding_news')) {
        $settings['library_news_page'] = (object) array(
          'module' => 'ding_path_alias_library_news_page',
          'token_type' => 'node',
          'groupheader' => t('Library news page'),
          'patterndescr' => t('Default path alias pattern'),
          'patterndefault' => '',
          'batch_update_callback' => 'ding_path_alias_library_news_page_pathauto_bulk_update_batch_process',
          'batch_file' => drupal_get_path('module', 'ding_path_alias') . '/ding_path_alias.pathauto.inc',
        );
      }
      if (module_exists('ding_library') && module_exists('ding_event')) {
        $settings['library_event_page'] = (object) array(
          'module' => 'ding_path_alias_library_event_page',
          'token_type' => 'node',
          'groupheader' => t('Library event page'),
          'patterndescr' => t('Default path alias pattern'),
          'patterndefault' => '',
          'batch_update_callback' => 'ding_path_alias_library_event_page_pathauto_bulk_update_batch_process',
          'batch_file' => drupal_get_path('module', 'ding_path_alias') . '/ding_path_alias.pathauto.inc',
        );
      }
      if (module_exists('ding_library')) {
        $settings['library_about_page'] = (object) array(
          'module' => 'ding_path_alias_library_about_page',
          'token_type' => 'node',
          'groupheader' => t('About library page'),
          'patterndescr' => t('Default path alias pattern'),
          'patterndefault' => '',
          'batch_update_callback' => 'ding_path_alias_library_about_page_pathauto_bulk_update_batch_process',
          'batch_file' => drupal_get_path('module', 'ding_path_alias') . '/ding_path_alias.pathauto.inc',
        );
      }
      return $settings;
      break;
  }
}
